;#options -m enhanced --no-rom
;
; 65C02 Store Zero (STZ) Test - zp / abs / zp,x / abs,x
; Split from 65C02_extended_opcodes_test.ca65 by Klaus Dormann
; Modified to use trap addresses and split into smaller tests
;

.include "65c02_test_common.inc"

; Macros for flag handling based on I_flag setting
        .if I_flag = 0
            .macro  load_flag   p1
            lda #p1&m8i          ;force enable interrupts (mask I)
            .endmacro
            .macro  cmp_flag    p1
            cmp #(p1|fao)&m8i   ;I_flag is always enabled + always on bits
            .endmacro
        .endif
        .if I_flag = 1
            .macro  load_flag   p1
            lda #p1|intdis      ;force disable interrupts
            .endmacro
            .macro  cmp_flag    p1
            cmp #(p1|fai)&m8    ;I_flag is always disabled + always on bits
            .endmacro
        .endif
        .if I_flag = 2
            .macro  load_flag   p1
            lda #p1
            ora flag_I_on       ;restore I-flag
            and flag_I_off
            .endmacro
            .macro  cmp_flag    p1
            eor flag_I_on       ;I_flag is never changed
            cmp #(p1|fao)&m8i   ;expected flags + always on bits, mask I
            .endmacro
        .endif
        .if I_flag = 3
            .macro  load_flag   p1
            lda #p1             ;allow test to change I-flag (no mask)
            .endmacro
            .macro  cmp_flag    p1
            cmp #(p1|fao)&m8    ;expected flags + always on bits
            .endmacro
        .endif

; Macros for setting and testing accumulator with status
            .macro      set_a       p1,p2       ;precharging accu & status
            load_flag p2
            pha         ;use stack to load status
            lda #p1     ;precharge accu
            plp
            .endmacro

            .macro      tst_a       p1,p2        ;testing result in accu & flags
            php         ;save flags
            cmp #p1     ;test result
            trap_ne
            pla         ;load status
            pha
            cmp_flag p2
            trap_ne
            plp         ;restore status
            .endmacro

            .macro  next_test   ;make sure, tests don't jump the fence
            lda test_case   ;previous test
            cmp #test_num
            trap_ne         ;test is out of sequence
test_num .set test_num + 1
            lda #test_num   ;*** next tests' number
            sta test_case
            .endmacro

; Zero page variables  
    .if I_flag = 2
flag_I_on:  .res  1           ;or mask to load flags
flag_I_off: .res  1           ;and mask to load flags
    .endif
zpt:        .res  5           ;5 bytes store/modify test area
test_case:  .res  1           ;current test number

        .DATA
        .org data_segment
abst:       .res  5           ;5 bytes store/modify test area

        .CODE
        .PC02
        .org code_segment
start:  cld
        ldx #$ff
        txs
        lda #0          ;*** test 0 = initialize
        sta test_case
test_num .set 0

;stop interrupts before initializing BSS
    .if I_flag = 1
        sei
    .endif

;retain status of interrupt flag
    .if I_flag = 2
        php
        pla
        and #4          ;isolate flag
        sta flag_I_on   ;or mask
        eor #<(~4)      ;reverse
        sta flag_I_off  ;and mask
    .endif

        next_test            

; testing STZ - zp / abs / zp,x / abs,x
        ldy #123    ;protect y
        ldx #4      ;precharge test area
        lda #7
tstz1:  sta zpt,x
        asl a
        dex
        bpl tstz1
        ldx #4
        set_a $55,$ff
        stz zpt     
        stz zpt+1
        stz zpt+2
        stz zpt+3
        stz zpt+4
        tst_a $55,$ff
tstz2:  lda zpt,x   ;verify zeros stored
        trap_ne     ;non zero after STZ zp
        dex
        bpl tstz2
        ldx #4      ;precharge test area
        lda #7
tstz3:  sta zpt,x
        asl a
        dex
        bpl tstz3
        ldx #4
        set_a $aa,0
        stz zpt     
        stz zpt+1
        stz zpt+2
        stz zpt+3
        stz zpt+4
        tst_a $aa,0
tstz4:  lda zpt,x   ;verify zeros stored
        trap_ne     ;non zero after STZ zp
        dex
        bpl tstz4
        next_test
        
        ldx #4      ;precharge test area
        lda #7
tstz5:  sta abst,x
        asl a
        dex
        bpl tstz5
        ldx #4
        set_a $55,$ff
        stz abst     
        stz abst+1
        stz abst+2
        stz abst+3
        stz abst+4
        tst_a $55,$ff
tstz6:  lda abst,x   ;verify zeros stored
        trap_ne     ;non zero after STZ abs
        dex
        bpl tstz6
        ldx #4      ;precharge test area
        lda #7
tstz7:  sta abst,x
        asl a
        dex
        bpl tstz7
        ldx #4
        set_a $aa,0
        stz abst     
        stz abst+1
        stz abst+2
        stz abst+3
        stz abst+4
        tst_a $aa,0
tstz8:  lda abst,x   ;verify zeros stored
        trap_ne     ;non zero after STZ abs
        dex
        bpl tstz8
        next_test
        
        ldx #4      ;precharge test area
        lda #7
tstz11: sta zpt,x
        asl a
        dex
        bpl tstz11
        ldx #4
tstz15:
        set_a $55,$ff
        stz zpt,x     
        tst_a $55,$ff
        dex
        bpl tstz15
        ldx #4
tstz12: lda zpt,x   ;verify zeros stored
        trap_ne     ;non zero after STZ zp,x
        dex
        bpl tstz12
        ldx #4      ;precharge test area
        lda #7
tstz13: sta zpt,x
        asl a
        dex
        bpl tstz13
        ldx #4
tstz16:
        set_a $aa,0
        stz zpt,x
        tst_a $aa,0
        dex
        bpl tstz16
        ldx #4
tstz14: lda zpt,x   ;verify zeros stored
        trap_ne     ;non zero after STZ zp,x
        dex
        bpl tstz14
        next_test
        
        ldx #4      ;precharge test area
        lda #7
tstz21: sta abst,x
        asl a
        dex
        bpl tstz21
        ldx #4
tstz25:
        set_a $55,$ff
        stz abst,x     
        tst_a $55,$ff
        dex
        bpl tstz25
        ldx #4
tstz22: lda abst,x   ;verify zeros stored
        trap_ne     ;non zero after STZ abs,x
        dex
        bpl tstz22
        ldx #4      ;precharge test area
        lda #7
tstz23: sta abst,x
        asl a
        dex
        bpl tstz23
        ldx #4
tstz26:
        set_a $aa,0
        stz abst,x
        tst_a $aa,0
        dex
        bpl tstz26
        ldx #4
tstz24: lda abst,x   ;verify zeros stored
        trap_ne     ;non zero after STZ abs,x
        dex
        bpl tstz24
        next_test

        cpy #123    ;Y unchanged?
        trap_ne

; All STZ tests completed successfully
        success

        .if ROM_vectors = 1
        .segment "VECTORS"
        .word   start     ; NMI vector  
        .word   start     ; Reset vector
        .word   start     ; IRQ/BRK vector
        .endif